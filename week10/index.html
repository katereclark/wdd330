<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Week 10 notes on readings for WDD 330.">
        <title>Week 10 Notes</title>
        <link rel="stylesheet" href="css/week10.css">
    </head>
    <body>
        <header>
            <h1>Week 10 Notes</h1>
        </header>
        <main>
            <h2>Questions</h2>
            <ul>
                <li>Is it more advisable to use PHP or JS for server-side validation, since JS can be disabled?</li>
            </ul>
            <h2>Notes</h2>
            <ul>
                <li>Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side</li>
                <li>We want to get the right data, in the right format</li>
                <li>We want to protect our users' data</li>
                <li>We want to protect ourselves</li>
                <li>minlength, maxlength, min, max, type, pattern, required</li>
                <li>For good user experience, indicate to the user when form fields are required. It isn't only good user experience, it is required by WCAG accessibility guidelines. Also, only require users to input data you actually need: For example, why do you really need to know someone's gender or title?</li>
                <li>if you set a custom error message, the element is considered to be invalid, and the specified error is displayed</li>
                <li>Customizing these error messages is one of the most common use cases of the constraint validation API</li>
                <li>This simple form uses the novalidate attribute to turn off the browser's automatic validation; this lets our script take control over validation.</li>
                <li>border-radius: 0 0 5px 5px; box-sizing: border-box;</li>
                <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings</li>
                <li> cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
                    credentials: 'same-origin', // include, *same-origin, omit</li>
                <li>Access-Control-Allow-Origin is prohibited from using a wildcard for requests with credentials: 'include'. In such cases, the exact origin must be provided; even if you are using a CORS unblocker extension, the requests will still fail.</li>
                <li>input[type="file"]</li>
                <li>input[type="file"][multiple]</li>
                <li>formData.append('title', 'My Vegas Vacation');
                    for (let i = 0; i < photos.files.length; i++) {
                    formData.append(`photos_${i}`, photos.files[i]);
                    }</li>
                <li>An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true.</li>
                <li>Request() accepts exactly the same parameters as the fetch() method.</li>
                <li>as request and response bodies are one use only. Making a copy like this allows you to make use of the request/response again while varying the init options if desired. The copy must be made before the body is read, and reading the body in the copy will also mark it as read in the original request.</li>
                <li>There is also a clone() method that creates a copy. Both methods of creating a copy will fail if the body of the original request or response has already been read, but reading the body of a cloned response or request will not cause it to be marked as read in the original.</li>
                <li>Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers' objects have a guard property. </li>
                <li>The static method error() returns an error response. Similarly, redirect() returns a response resulting in a redirect to a specified URL. These are also only relevant to Service Workers.</li>
                <li>Feature Detection: if (window.fetch) {
                    // run my fetch request here
                    } else {
                    // do something with XMLHttpRequest?
                    }</li>
            </ul>
        </main>
    </body>
</html>